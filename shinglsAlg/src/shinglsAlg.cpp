// shinglsAlg.cpp: определяет точку входа для консольного приложения.

#include <ShingleApp.h>
#include "../src/gsoap_autogenerated/shingle.nsmap"
#include <signal.h>

using namespace DePlaguarism;
using namespace std;

const string exitCommand = "exit";
const string reloadCommand = "reload";

string commandStr;

//! Used here to output wsdl if needed.
    /*!
      \param soap is server object, where we wait for http request.
    */
int http_get(struct soap *soap);

void sigpipe_handler(int x) { }

//! Starts infinite loop of service.
    /*!
      Accepts as parameter pointer to server object.
      \sa soapStop(), soapStart()
    */
#ifdef WIN32
unsigned _stdcall runService(void *);
#else
void * runService(void *);
#endif

void sigterm_handler(int signum);

//! Creates server object, starts it.
    /*!
      \param tid is thread id pointer, where will be written an id of new thread.
      \return Server object.
      \sa soapStop(), runService()
    */
ShingleApp * soapStart(THREAD_TYPE *tid);

//! Stops and deallocates all the memory allocated by server object.
    /*!
      \param tid is id of service thread.
      \param srv is a pointer to server object.
      \sa soapStart(), runService()
    */
void soapStop(ShingleApp * srv, THREAD_TYPE tid);


int main(int argc, char* argv[]) {
    setlocale(LC_ALL, "ru_RU.UTF-8");
    THREAD_TYPE tid;
    struct sigaction action;
    memset(&action, 0, sizeof(struct sigaction));
    action.sa_handler = sigterm_handler;
    sigaction(SIGTERM, &action, NULL);
    sigaction(SIGINT, &action, NULL);
    const char * configName = ( argc > 2 ) ? argv[2] : DefaultValues::CONFIG_FILE.c_str();
    Config & instance = Config::getInstance();
    instance.loadConfig(configName);
    ShingleApp * srv = soapStart(&tid);
    do {
        cin >> commandStr;
        if (commandStr == reloadCommand) {
            soapStop(srv, tid);
            instance.loadConfig(configName);
            srv = soapStart(&tid);
        }
    } while (commandStr != exitCommand);
    soapStop(srv, tid);
    return 0;
}

ShingleApp * soapStart(THREAD_TYPE * tid) {
    ShingleApp *srv = new ShingleApp();
    soap_set_imode(srv, SOAP_C_UTFSTRING);
    soap_set_omode(srv, SOAP_C_UTFSTRING);
    //srv->accept_flags = SO_NOSIGPIPE;  /* some systems accept this */
    srv->socket_flags = MSG_NOSIGNAL;  /* others need this */
    //signal(SIGPIPE, sigpipe_handler);  /* and when the above are not supported, we use a sigpipe handler */
    unsigned threadID;
    THREAD_CREATE(tid, runService, (void*)srv, threadID);
    srv->log() << "Application started!\n";
    return srv;
}

void soapStop(ShingleApp *srv, THREAD_TYPE tid) {
    srv->stop();
    // perform a request to server bacause of blocking accept()
    struct sockaddr_storage sa;
    if (inet_pton(AF_INET,Config::getInstance().GSOAP_IF.c_str(), &(((struct sockaddr_in *)&sa)->sin_addr))) {
        sa.ss_family = AF_INET;
        int sockfd;
        struct sockaddr_in * serv_addr = (struct sockaddr_in *)&sa;
        sockfd = socket(sa.ss_family, SOCK_STREAM, 0);
        serv_addr->sin_port = htons(Config::getInstance().SERVICE_PORT);
        connect(sockfd,(struct sockaddr *) serv_addr,sizeof(*serv_addr));
        write(sockfd, "", 1);
        close(sockfd);
    } else if (inet_pton(AF_INET6,Config::getInstance().GSOAP_IF.c_str(), &(((struct sockaddr_in6 *)&sa)->sin6_addr))) {
        sa.ss_family = AF_INET6;
        int sockfd;
        struct sockaddr_in6 * serv_addr = (struct sockaddr_in6 *)&sa;
        sockfd = socket(sa.ss_family, SOCK_STREAM, 0);
        serv_addr->sin6_port = htons(Config::getInstance().SERVICE_PORT);
        connect(sockfd,(struct sockaddr *) serv_addr,sizeof(*serv_addr));
        write(sockfd, "", 1);
        close(sockfd);
    } else {
        srv->log() << "Just perform a request to server to stop it.\n";
    }
    THREAD_JOIN(tid);
    srv->log() << "Service stopped! Bye-bye...\n";
    delete srv;
}

int http_get(struct soap *soap) {
    FILE *fd = NULL;
    char *s = strchr(soap->path, '?');
    if (!s || strcmp(s, "?wsdl"))
        return SOAP_GET_METHOD;
    fd = fopen("shingle.wsdl", "rb"); // open WSDL file to copy
    if (!fd)
        return 404; // return HTTP not found error
    soap->http_content = "text/xml"; // HTTP header with text/xml content
    soap_response(soap, SOAP_FILE);
    while (true) {
        size_t r = fread(soap->tmpbuf, 1, sizeof(soap->tmpbuf), fd);
        if (!r)
            break;
        if (soap_send_raw(soap, soap->tmpbuf, r))
            break; // can't send, but little we can do about that
    }
    fclose(fd);
    soap_end_send(soap);
    return SOAP_OK;
}

void sigterm_handler(int signum)
{
    commandStr = exitCommand;
}

#ifdef WIN32
unsigned _stdcall runService(void * app)
#else
void * runService(void * app)
#endif
{
    ShingleApp * srv = (ShingleApp*)app;
    srv->fget = http_get;
    srv->log() << "Server putted up!\n" << srv->nowToStr() << '\n';
    srv->setMain();
    while (srv->run(Config::getInstance().SERVICE_PORT)){
        srv->log() << "Emergency shoutdown! Waiting 10 seconds.\n";
        SLEEP(10000);
    }
    return NULL;
}
