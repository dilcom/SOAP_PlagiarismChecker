// shinglsAlg.cpp: определяет точку входа для консольного приложения.

#include "../headers/ShingleApp.h"
#include "../src/gsoap_autogenerated/shingle.nsmap"
#include <curl/curl.h>

#ifdef WIN32
unsigned _stdcall runService(void *);
#else
void * runService(void *);
#endif

const string exitCommand = "exit";
const string resetDBcommand = "resetdb";

using namespace DePlaguarism;
using namespace std;

int http_get(struct soap *soap); ///< it`s being used to responce with wsdl when needed
void sigpipe_handler(int x) { }
ShingleApp * soapStart(THREAD_TYPE *tid);
void soapStop(ShingleApp * srv, THREAD_TYPE tid);
void loadConfig(const char * configName);
void saveConfig(const char * configName);

int main(int argc, char* argv[]) {
    setlocale(LC_ALL, "ru_RU.UTF-8");
    THREAD_TYPE tid;
    const char * configName = ( argc > 2 ) ? argv[2] : DefaultValues::CONFIG_FILE.c_str();
    Config & instance = Config::getInstance();
    instance.loadConfig(configName);
    ShingleApp * srv = soapStart(&tid);
    string a;
    do {
        cin >> a;
        if (a == resetDBcommand)
            srv->resetDB();
    } while (a != exitCommand);
    soapStop(srv, tid);
    return 0;
}

ShingleApp * soapStart(THREAD_TYPE * tid) {
    ShingleApp *srv = new ShingleApp();
    soap_set_imode(srv, SOAP_C_UTFSTRING);
    soap_set_omode(srv, SOAP_C_UTFSTRING);
    //srv->accept_flags = SO_NOSIGPIPE;  /* some systems accept this */
    srv->socket_flags = MSG_NOSIGNAL;  /* others need this */
    //signal(SIGPIPE, sigpipe_handler);  /* and when the above are not supported, we use a sigpipe handler */
    unsigned threadID;
    THREAD_CREATE(tid, runService, (void*)srv, threadID);
    srv->log() << "Application started!\n";
    return srv;
}

void soapStop(ShingleApp *srv, THREAD_TYPE tid) {
    srv->stop();
    CURL *curl = curl_easy_init();
    if(curl) {
      curl_easy_setopt(curl, CURLOPT_URL, DePlaguarism::Config::getInstance().GSOAP_IF.c_str());
      curl_easy_setopt(curl, CURLOPT_PORT, DePlaguarism::Config::getInstance().SERVICE_PORT);
      curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 1);
      curl_easy_perform(curl); 
      curl_easy_cleanup(curl);
    }
    THREAD_JOIN(tid);
    srv->log() << "Service stopped! Bye-bye...\n";
    delete srv;
}

int http_get(struct soap *soap) {
    FILE *fd = NULL;
    char *s = strchr(soap->path, '?');
    if (!s || strcmp(s, "?wsdl"))
        return SOAP_GET_METHOD;
    fd = fopen("shingle.wsdl", "rb"); // open WSDL file to copy
    if (!fd)
        return 404; // return HTTP not found error
    soap->http_content = "text/xml"; // HTTP header with text/xml content
    soap_response(soap, SOAP_FILE);
    while (true) {
        size_t r = fread(soap->tmpbuf, 1, sizeof(soap->tmpbuf), fd);
        if (!r)
            break;
        if (soap_send_raw(soap, soap->tmpbuf, r))
            break; // can't send, but little we can do about that
    }
    fclose(fd);
    soap_end_send(soap);
    return SOAP_OK;
}

#ifdef WIN32
unsigned _stdcall runService(void * app)
#else
void * runService(void * app)
#endif
{
    ShingleApp * srv = (ShingleApp*)app;
    srv->fget = http_get;
    srv->log() << "Server putted up!\n" << srv->nowToStr() << '\n';
    srv->setMain();
    while (srv->run(Config::getInstance().SERVICE_PORT)){
        srv->log() << "Emergency shoutdown! Waiting 10 seconds.\n";
        SLEEP(10000);
    }
    return NULL;
}
